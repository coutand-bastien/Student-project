"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var keys_1 = require("./keys");
var ts = require("typescript");
var path = require("path");
var semver = require("semver");
function parseFile(file, target) {
    return ts.createSourceFile(file.name, file.textContent, target || ts.ScriptTarget.ES5, 
    /*setParentNodes*/ true);
}
exports.parseFile = parseFile;
/**
 * For some reason, typescript on windows doesn't like back slashes
 * @param fileName The file name to be normalized
 */
function normalizeFileForTypescript(fileName) {
    return fileName.replace(/\\/g, '/');
}
exports.normalizeFileForTypescript = normalizeFileForTypescript;
/**
 * For some reason, typescript on windows doesn't like back slashes
 * @param fileName The file name to be normalized
 */
function normalizeFileFromTypescript(fileName) {
    return path.normalize(fileName);
}
exports.normalizeFileFromTypescript = normalizeFileFromTypescript;
function getTSConfig(options) {
    return options[keys_1.CONFIG_KEY];
}
exports.getTSConfig = getTSConfig;
function getProjectDirectory(options) {
    return path.dirname(options[keys_1.CONFIG_KEY_FILE] || '.');
}
exports.getProjectDirectory = getProjectDirectory;
/**
 * Verifies that the installed version of typescript satisfies '>=2.4` and otherwise: throws an exception
 */
function guardTypescriptVersion() {
    if (!semver.satisfies(ts.version, '>=2.4')) {
        throw new Error("Installed typescript version " + ts.version + " is not supported by stryker-typescript. Please install version 2.5 or higher (`npm install typescript@^2.5`).");
    }
}
exports.guardTypescriptVersion = guardTypescriptVersion;
var printer = ts.createPrinter({
    newLine: os.EOL === '\r\n' ? ts.NewLineKind.CarriageReturnLineFeed : ts.NewLineKind.LineFeed,
    removeComments: false
});
function printNode(node, originalSourceFile) {
    return printer.printNode(ts.EmitHint.Unspecified, node, originalSourceFile);
}
exports.printNode = printNode;
function tsExtensions() {
    // Since ts 2.5 the ts.Extension enum is a string-based enum
    if (semver.satisfies(ts.version, '>=2.5')) {
        return Object.keys(ts.Extension).map(function (extension) { return ts.Extension[extension]; });
    }
    else {
        // We know that pre 2.5 should have these extensions:
        return ['.ts', '.tsx', '.js', '.jsx'];
    }
}
function isTypescriptFile(fileName) {
    return tsExtensions().some(function (extension) { return fileName.endsWith(extension); });
}
exports.isTypescriptFile = isTypescriptFile;
function isJavaScriptFile(file) {
    return file.name.endsWith('.js') || file.name.endsWith('.jsx');
}
exports.isJavaScriptFile = isJavaScriptFile;
function isMapFile(file) {
    return file.name.endsWith('.map');
}
exports.isMapFile = isMapFile;
/**
 * Determines whether or not given file is a typescript header file (*.d.ts)
 */
function isHeaderFile(fileName) {
    return fileName.endsWith('.d.ts');
}
exports.isHeaderFile = isHeaderFile;
//# sourceMappingURL=tsHelpers.js.map